# Adding a new function

## Overview

TODO: Write me.

## Prerequisites

TODO: Write me.

## Write a definition in YAML

### Function definition (functions.yaml)

At first, to add a new layer function, you must write a definition of the layer function to [functions.yaml](/build-tools/code_generator/functions.yaml).

TODO: Write format description of `functions.yaml`.

### Template type instantiation

Second, add a type specification of the new function to [function_types.yaml](/build-tools/code_generator/function_types.yaml).
A function class generated by the code generator and most of existing functions are written as a template class in which storage types are defined as (a) template argument(s) of the class.
The build system will generate a source file in which temlate instantiation with specified types are written. Also, the typed functions are registered to a function factory so that a typed function can be queried with a type configuration name.

TODO: Write format description of `function_types.yaml`.

## Generate code template and interfaces by CMake

TODO: Move this to architecture overview.

By running cmake command in an usual way when we build NNabla, our build system will create our build system will create the following files from the function definition.

* Function class template (if it does not exist. It does not overwrite.):
  * `include/nbla/function/${snake_name}.hpp`
  * `src/nbla/function/generic/${snake_name}.cpp`

* Templated type instantiation of functions and solvers.
  * `src/nbla/function/${snake_name}.cpp`
  * `src/nbla/solver/${snake_name}.cpp`

* Initialization (array/function/solver/communicator registration to factories.)
  * `src/nbla/init.cpp`

* Python interfaces at `python/src/nnabla`
  * `_version.py`
  * `function.pxd`
  * `function.pyx`
  * `function_bases.py`
  * `solver.pxd`
  * `solver.pyx`

* Serializer/Deserializer
  * `python/src/nnabla/utils/load_function.py`
  * `python/src/nnabla/utils/save_function.py`
  * `src/nbla_utils/nnp_impl_create_function.cpp`

END OF TODO: Move this to architecture overview. 


By running cmake as described in the build instruction,

```shell
cmake ..
```

a function class template is generated to the following files.

* `include/nbla/function/${snake_name}.hpp`
* `src/nbla/function/generic/${snake_name}.cpp`

Although the function template are useful, elementwise operation functions such as an ativation function can be written by using macro functions.

TODO: Add details of elementwise macro.

## Write your function implementation

The template files generated above kindly contain help documentation for writing your implementation. Add your function logic of forward pass and backward pass.

## Write unit testing

All function unittests are found [here](/python/test/function/]).

TODO: Write me.

NOTE: Unit testing in C++ is often demanded by embedded engineers. Writing unit testing in C++ side from scratch from now requires much effort, and imposes double-maintenance cost over C++ and Python unittests. Also, testing in Python is much easier to debug. Hence, a possible solution to this currently we are thinking is that creating a framwork generating C++ unit testing code of each functions from our Python testing framework (`function_tester`). However, we do not have any specific plan to add this feature soon. Contributions are welcome.

## (DO NOT FORGET!) Add a function doc to sphinx.

TODO: Write me.

## You want to add a CUDA function too?

We know many developers use CUDA to accelerate processing speed. See contribution guide of [CUDA extension](https://github.com/sony/nnabla-ext-cuda/blob/master/CONTRIBUTING.md).
